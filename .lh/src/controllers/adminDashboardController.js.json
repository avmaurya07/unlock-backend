{
    "sourceFile": "src/controllers/adminDashboardController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1766933716690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1766933716690,
            "name": "Commit-0",
            "content": "const mongoose = require(\"mongoose\");\nconst User = require(\"../models/User\");\nconst Publisher = require(\"../models/Publisher\");\nconst Listing = require(\"../models/Listing\");\n\nfunction parseDateRange(req) {\n  const { from, to } = req.query;\n\n  const range = {};\n  if (from) range.$gte = new Date(from);\n\n  if (to) {\n    const end = new Date(to);\n    end.setHours(23, 59, 59, 999);\n    range.$lte = end;\n  }\n\n  return Object.keys(range).length ? range : null;\n}\n\n/**\n * GET /api/admin/dashboard/summary\n * Returns:\n * - total users, total publishers\n * - publisher subscription health (active/expired/suspended)\n * - listing status counts (pending/approved/rejected)\n * - pending approvals (same as pending)\n */\nexports.getAdminSummaryStats = async (req, res) => {\n  try {\n    const now = new Date();\n    const createdAtRange = parseDateRange(req);\n\n    // Listing filters (optional date range)\n    const listingFilter = {};\n    if (createdAtRange) listingFilter.createdAt = createdAtRange;\n\n    const [\n      totalUsers,\n      totalAdmins,\n      totalPublishers,\n      listingStatusCountsRaw,\n      pendingApprovals,\n      publisherHealthRaw\n    ] = await Promise.all([\n      User.countDocuments({ role: \"user\" }),\n      User.countDocuments({ role: \"admin\" }),\n      Publisher.countDocuments({}),\n      Listing.aggregate([\n        { $match: listingFilter },\n        { $group: { _id: \"$status\", count: { $sum: 1 } } }\n      ]),\n      Listing.countDocuments({ ...listingFilter, status: \"pending\" }),\n      // Publisher subscription health computed by expiry + status\n      Publisher.aggregate([\n        {\n          $addFields: {\n            computedSubStatus: {\n              $switch: {\n                branches: [\n                  { case: { $eq: [\"$subscriptionStatus\", \"suspended\"] }, then: \"suspended\" },\n                  {\n                    case: {\n                      $and: [\n                        { $eq: [\"$subscriptionStatus\", \"active\"] },\n                        { $gte: [\"$subscriptionExpiry\", now] }\n                      ]\n                    },\n                    then: \"active\"\n                  }\n                ],\n                default: \"expired\"\n              }\n            }\n          }\n        },\n        { $group: { _id: \"$computedSubStatus\", count: { $sum: 1 } } }\n      ])\n    ]);\n\n    const listingStatusCounts = { pending: 0, approved: 0, rejected: 0 };\n    for (const row of listingStatusCountsRaw) {\n      listingStatusCounts[row._id] = row.count;\n    }\n\n    const publisherHealth = { active: 0, expired: 0, suspended: 0 };\n    for (const row of publisherHealthRaw) {\n      publisherHealth[row._id] = row.count;\n    }\n\n    return res.json({\n      success: true,\n      summary: {\n        users: {\n          totalUsers,\n          totalAdmins,\n          totalAccounts: totalUsers + totalAdmins\n        },\n        publishers: {\n          totalPublishers,\n          subscriptionHealth: publisherHealth\n        },\n        listings: {\n          statusCounts: listingStatusCounts,\n          pendingApprovals\n        }\n      }\n    });\n  } catch (err) {\n    return res.status(500).json({ success: false, message: err.message });\n  }\n};\n\n/**\n * GET /api/admin/dashboard/listings-by-type\n * Optional filters: ?status=approved&from=YYYY-MM-DD&to=YYYY-MM-DD\n */\nexports.getListingsByTypeStats = async (req, res) => {\n  try {\n    const createdAtRange = parseDateRange(req);\n    const { status } = req.query;\n\n    const match = {};\n    if (createdAtRange) match.createdAt = createdAtRange;\n    if (status && [\"pending\", \"approved\", \"rejected\"].includes(status)) match.status = status;\n\n    // Listing.type = ObjectId -> lookup ListingType name\n    const rows = await Listing.aggregate([\n      { $match: match },\n      { $group: { _id: \"$type\", count: { $sum: 1 } } },\n      {\n        $lookup: {\n          from: \"listingtypes\", // collection name (Mongoose auto pluralizes)\n          localField: \"_id\",\n          foreignField: \"_id\",\n          as: \"typeDoc\"\n        }\n      },\n      { $unwind: { path: \"$typeDoc\", preserveNullAndEmptyArrays: true } },\n      {\n        $project: {\n          _id: 0,\n          typeId: \"$_id\",\n          typeName: { $ifNull: [\"$typeDoc.name\", \"Unknown\"] },\n          count: 1\n        }\n      },\n      { $sort: { count: -1 } }\n    ]);\n\n    return res.json({ success: true, data: rows });\n  } catch (err) {\n    return res.status(500).json({ success: false, message: err.message });\n  }\n};\n\n/**\n * GET /api/admin/dashboard/listings-trends\n * Default: last 12 months (approved+pending+rejected) grouped monthly\n * Optional:\n *  - ?status=approved\n *  - ?months=6\n */\nexports.getListingsTrendStats = async (req, res) => {\n  try {\n    const { status, months = 12 } = req.query;\n\n    const m = Math.min(Math.max(parseInt(months, 10) || 12, 1), 24);\n\n    const now = new Date();\n    const start = new Date(now);\n    start.setMonth(start.getMonth() - (m - 1));\n    start.setDate(1);\n    start.setHours(0, 0, 0, 0);\n\n    const match = { createdAt: { $gte: start, $lte: now } };\n    if (status && [\"pending\", \"approved\", \"rejected\"].includes(status)) {\n      match.status = status;\n    }\n\n    const rows = await Listing.aggregate([\n      { $match: match },\n      {\n        $group: {\n          _id: { year: { $year: \"$createdAt\" }, month: { $month: \"$createdAt\" } },\n          count: { $sum: 1 }\n        }\n      },\n      { $sort: { \"_id.year\": 1, \"_id.month\": 1 } },\n      {\n        $project: {\n          _id: 0,\n          year: \"$_id.year\",\n          month: \"$_id.month\",\n          count: 1\n        }\n      }\n    ]);\n\n    return res.json({\n      success: true,\n      range: { months: m, start, end: now },\n      data: rows\n    });\n  } catch (err) {\n    return res.status(500).json({ success: false, message: err.message });\n  }\n};\n"
        }
    ]
}